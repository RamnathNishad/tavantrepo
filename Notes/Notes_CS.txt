using command line tool for .net core application development:-

basic types:- 
a) value-types:-
predefined:
int,char,double,float,decimal,datetime,long,byte,uint,short,boolean and so on
user-defined types:-
-enum
-struct


b) reference types:-
predefined:string
user-defined types:-
-arrays
-classes
-interfaces


Arrays:-
-single-dimension:-
-multi-dimension:-
	-i)Rectangular  array: a particular dimension will have same number of items
	ii)Jagged array:- a dimension may have different number of items

--Data-conversions:-
1) value-to-value :- lower to higher(implicit) but higher to lower precision (explicit) as data loss may happen
2) value-to-reference:- boxing
3) reference-to-value:- unboxing
4) reference-to-reference:- base to derived or vice-versa


==============Convert vs Parse vs TryParse========================
1) Convert :- will give error is string is invalid and gives default value 0 if string null else
success conevrsion
2) TryParse:- if string is invalid it gives default value and if null also gives default value else true if successfull converision
3) Parse:- if string valid then successfull conversion, if string is null or invalid,it gives exception ArgumentNullExcpetion and FormatException respectively

==================DateTime parsing=============================



===================static modifier======================
it is a modifier which indicates the member of a class is not meant for its instances.
it is allocated once per class not per instance.
so it is accessed also using class name.

static method can only access static member(methods n fields) but non-static methods can access
both static as well as non static members also.

static can be called class name only.



====================out vs ref=================
Normally value-type variables are passed to a method by-value and objects are passed by-reference by default.
If we want to pass value-type variables also by-reference to a method, we can use out or ref keyword.
out: we use when the modification of the parameter is mandatory before leaving the method
ref:- optional modification of the parameter inside the method passed.


====================const vs readonly=====================
const:- is declared and assigned at the same time and cannot be changed till its scope is there.
readonly:- can be assigned only through constructor method i.e. one time assignment. later cannot be modified.



Q. Create an array for the cinema hall tickets of 25 by 25 seats.
User enters the number of seats to be booked. Once booking is successfull, the seat should be marked as 1. For e.g. if the user enter 2 seats to be booked, then seat[0][0]=1 and seat[0][1]=1 should be assigned. If number of tickets is unavailable, it should display error.
After booking, all the seats should be displayed on screen which should show 0 in free seats and 1 in booked seats.








OOPs:-
1) Abstraction:-  
ecommerce----customer----->car,family, cid,cname,contactno,billing address, pincode
employee----> ecode,ename,salary,emailid 

2) Encapsulation:- putting all the related things together

relations:-
3.1) Inheritance:- 
	kind-of or is-a relations
3.2) Aggregation/Composition:- part-of or has-a relation
	Aggregation:- contained objects still exist even if their container is not there
	Composition:- if the container is not their, contained object also does not exists
			Policy---->Nominee

	cardinality ratio:
		1:1-----> COURSE------LECTURER
		1:m---->DEPARTMENT----->EMPLOYEE
		m:1---->
		m:n---->STUDENT------>COURSE
 


4) Polymorphism:- One object behaves differently in different situations
	servant----->cook,watchman,tutor
a) static polymorphism:- overloading of the method. binding of the object to a type is pre-decided during compilation and cannot be changed to other type at runtime.
	
b) dynamic polymorphism:-	overriding of the methods across inheritance. binding of the object is decided at runtime 




=================constructor and destructor==================
ctor:- 
-it is autimatically called when object is created
-it is used to perform initial tasks as soon as object comes into memory like data-initialization is one the task, connection creation , file opening before manupulating.

-syntax=>
*name must be same as classname
*no return type
class Employee
{
	public Employee(){}
}
*ctor can be overloaded multiple times
ctor can be :
-private :- if we dont' want user to create instance of the class, we shud use private ctor
	Employee obj=new Employee();// not allowed
	e.g. Singleton pattern does not allow object creation by the users rather instance is provided by the server for use.
-public :- object creation is allowed by the users
-static:- is used to access or initialized static fields of the class as it is called only once and not for each instance creation and before non-static ctor, static ctor is called.


===================constructor chaining=================
It is used in inheritance where base and derived classes both field initialization through ctors.
-derived class ctor needs to pass data to the base class ctor using base(p1,p2,...)
Note: derived class ctor automatically calls base class blank ctor but if the base class has parameterized ctor, we need to call it manually
	public Derived(int a,int b): base(a)
	{
		this.b=b;
	}



depicting cardinality ratios:

class Product
{
	int pid;
	int price;
}
class Order
{
	int oid;
	DateTime orderDate;
	Product[] items;
}

class Course
{
	int cid;
	string cname;
}
class Faculty
{
	int fid;
	string fname;
	Course course;
}

-----------Polymorphism----------------
1) static :- overloading :- no of parameters,data-types of parameters.
2) dynamic :- overriding: base to derived class 
		-virtual:- optional overridding at derived level
		-abstract:- mandatory overriding at derived level
		-interface
*abstract keyword:
-abstract method does not have definition
-abstract must be overridden at derived classes
-class also must be declared as an abstract if there are any abstract methods in it.
-an abstract class may have bothe non-abstract as well as abstract methods
-an abstract class instance is allowed using new keyword

interface:-
we use in place multiple inheritance, interfaces are used
class Demo : Parent,IinterfaceTypr
{

}

* by default interface methods are public and abstract

interface IEmployee
{
}
class Employee : Parent,IEmployee
{

}


*inteface instance is also not allowed same as abstract class
* we can implement multiple interfaces in a class
*interface inheritance also allowed
interface I1
{
}

interface I2 : I1
{
}

explicit implementation
interface I1
{
	void Display();
}
interface I2
{
	void Display();
}
class Demo : I1,I2
{
	public void I1.Display()
	{
	}
	public void I2.Display()
	{
	}
}

I1 obj=new Demo();
I1.Display();

I2 obj2=new Demo();
obj2.Display();







-------destructor---
-executed automatically when object is destroyed
-we use for some clearling tasks like resource releasing 
syntax=>

	~Employee()
	{
		//resource releasing statements
	}
-No access specifier
-No overloading of destructor
-non-parameterised
-no return type

========================Collections======================
unlike arrays, collections have variable size and can grow and shrink at runtime.
Two types of collections:-
1) Non-generics:-  It is not strongly-typed i.e. everything is stored as an object tyoe so while accessing we need check their type and accordingly type-cast before using it.
problem:
	-if typecasting is wrong, exception will be there
	-extra lines of code for checking the types

System.Collections  e.g. ArrayList,Hashtable,Stack,Queue


2) Generics:- System.Collections.Generic:- stronly-typed 
System.Collections.Generics
	List<>
	Dictionary<,>	
	Stack<>,Queue<>
	SortedDictionary<,>
	Hashset<>:- no duplicate values and supports set operations Union,Intersect,Minus


======================Sorting Collections=========================
It gives one Sort() which is default sorting.
It is already implemented for primitive value collection but for custom type collection we need implement it.
two ways to do it:
1) IComparable<> :- default Sort()
2) IComparer<>:- custom sort wherein we need to pass the comparer object

==========================Exception handling===============================
Errors:
1) Compilation error:- syntax mistakes and detected by compiler during compilation. Developers need to rectify.
2) Runtime errors: it is notified during execution
	a) logical errors:-  when desired expected output is not there, so we need to check the various outputs and execution paths. Testing is done here for getting these errors.
	In visual studio we do debugging to find logical errors:
	i)break points:- program pauses at these points so we can analyse the status of variables and output. program must be in debug mode not in without debug
		we can use debug windows:
		i)watch window:- tracing some variables , how their values are chaning
		ii)immediate window:- any expressions on the state of variables can be checked
		iii)Locals window:- for block level variable, we use 	
	
	Debugging steps:
		i)steo over --line by line----> F10
		ii) step into :- debugging continuos inside the sun-methods---F11
		iii) step-out:- continuing without debugging further

	b) Exceptions:- no syntax or logic mistakes but program behaves abnormal on some situations and terminates abruptly.
	i) Pre-defined exceptions:- already exception classes are defined in the compiler
	CLR collects all the exception details and wraps in an exception object and throws it. Application has to catch the exception and handle it else it will terminate the application.
		we handle exception using try/catch/finally
	
	ii) Custom exceptions:-
	a)define the exception class by inheriting with System.Exception
	b) throw the exception
	c) handle it 

System.Exception


Predefined :- SystemException----Exception

Custom:- ApplicationException---Exception



Inner exception:-

try
{
 //divide by zero
}
catch(DivideByZeroException ex)
{
	//logging in file
	throw FileNotFoundException 
	
}


=================Properties=====================
These are way to access the private fields of a class called get/set methods or properties.
	public int Ecode{get;set;}

property can be readoonly also by making set as private or do not define it at all.
It gives object initializer as well as collection initializer syntaxes.

==========================delegate================
-It is a data-type which can hold references of functions.
-It is like function pointer f C/C++ but it is more type-safe means it binds only a particular signature of methods specified during delegate declaration.
steps:
1) declare :- what kind of methods can be binded
2) initialize:- binding of the methods
3) call:- invoking the binded methods

Usage: it is used to peform dynamic invocation of methods at runtime without having any relations among the objects.

Delegates are of two categories:
1) Single-Cast delegate:- only one method is binded at a time
2) Multi-cast delegate:- more than one methods are binded and invoked together. it is recommended for methods with void return type as we get only result from the last method invoked.
d1=>m1,m2
d2=>m3,m4,m5
d3=d1+d2;
d3()
d3=d3-d1;
d3();

* with delegate we can also bind anonymous methods
* delegate also accepts lambda expression using =>
	(a,b)=>{return a+b;}

======predefined generic delegates========
Action<>:- used for void return type methods
Func<>:- used for methods with some return type






 













